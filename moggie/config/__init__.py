import json
import math
import os
import re
import time
import struct
from configparser import ConfigParser, NoOptionError, _UNSET

from ..crypto.aes_utils import make_aes_key
from ..crypto.passphrases import stretch_with_scrypt
from ..crypto.recovery import RecoverableData, RecoverySvc, generate_recovery_code
from ..util.dumbcode import dumb_decode, dumb_encode_asc


APPNAME    = 'moggie'  #'mailpile'
APPNAME_UC = 'Moggie'  #'Mailpile'
APPVER     = '2.0.0'
APPURL     = 'https://github.com/BjarniRunar/moggie'

RECOVERY_SERVICE_URL = 'https://recovery.mailpile.is/recovery_svc'


class ConfigSectionProxy:
    _KEYS = {}

    def __init__(self, ac, section):
        self._ac = ac
        self._section = section

    def __contains__(self, attr):
        return (attr in self._ac[self._section])

    def __getattr__(self, attr):
        if attr[:1] == '_':
            return object.__getattribute__(self, attr)
        if attr in self._KEYS:
            try:
                return self._KEYS[attr](self._ac.get(self._section, attr))
            except NoOptionError:
                return None
        else:
            return object.__getattribute__(self, attr)

    def __setattr__(self, attr, val):
        if attr[:1] == '_':
            return object.__setattr__(self, attr, val)
        if attr in self._KEYS:
            if val is not None:
                val = str(val)
            return self._ac.set(self._section, attr, val)
        raise KeyError(attr)

    def magic_test(self):
        return 'magic'


class RecoverySvcConfig(ConfigSectionProxy):
    _KEYS = {
         'host': str,
         'port': int,
         'kite_name': str,
         'kite_secret': str}


class ProfileConfig(ConfigSectionProxy):
    _KEYS = {
        'username': str,
        'password': str}


class AppConfig(ConfigParser):

    GENERAL = 'App'
    SECRETS = 'Secrets'
    RECOVERY = 'Recovery Data'
    RECOVERY_SVC = 'Recovery Service'
    PROFILE_PREFIX = 'Profile '

    INITIAL_SETTINGS = [
       (GENERAL, 'recovery_svc_url', RECOVERY_SERVICE_URL),
       (GENERAL, 'config_backups', '10')]

    PREAMBLE = """\
# This file was auto-generated by %s v%s.
#
# NOTE: Although you can edit it by hand, comments will be lost and sections
#       may get reordered when the app next saves its settings.
#
#############################################################################

""" % (APPNAME_UC, APPVER) 

    DIGIT_RE = re.compile('\d')

    ALLOWED_SECTIONS = [GENERAL, SECRETS, RECOVERY, RECOVERY_SVC]
    ALLOWED_SECTION_PREFIXES = [PROFILE_PREFIX]

    def __init__(self, profile_dir):
        self.filepath = os.path.join(profile_dir, 'config.rc')
        self.backups = os.path.join(profile_dir, 'backups')
        super().__init__(
            delimiters=('=',),
            comment_prefixes=('#',),
            strict=True,
            interpolation=None)

        self.aes_key = None
        self.iv = list(struct.unpack('II', os.urandom(8))) + [int(time.time())] + [0]
        self.keep_private = {
            self.SECRETS + '/master_key',
            self.SECRETS + '/config_key',
            self.PROFILE_PREFIX+'N/context.N.account.N.password'}

        self.read(self.filepath)
        for sec, opt, val in self.INITIAL_SETTINGS:
            if sec not in self:
                self.add_section(sec)
            if opt not in self._sections[sec]:
                self.set(sec, opt, val, save=False)

        if 'passphrase' in self[self.SECRETS]:
            self.provide_passphrase(self[self.SECRETS]['passphrase'])

        self.last_rotate = os.path.getmtime(self.filepath)
        self.recovery_svc = RecoverySvcConfig(self, self.RECOVERY_SVC)
        self.profiles = dict((p, ProfileConfig(self, p))
            for p in self if p.startswith(self.PROFILE_PREFIX))

    def rotate(self):
        now = time.time()
        if not os.path.exists(self.filepath):
            return
        if not os.path.exists(self.backups):
            os.mkdir(self.backups, 0o700)

        exp = 2
        count = int(self.get(self.GENERAL, 'config_backups', fallback=5))
        fudge = 300
        last_min_age = 0
        for i in reversed(range(0, count+1)):
            dest = os.path.join(self.backups, 'config.rc.%2.2d' % (i+1,))
            if i > 0:
                src = os.path.join(self.backups, 'config.rc.%2.2d' % (i,))
            else:
                src = self.filepath
            if os.path.exists(src):
                min_age = min(last_min_age + 24*3600, int(fudge * (exp**i)))
                if os.path.exists(dest):
                   if now - os.path.getmtime(dest) > min_age:
                       os.remove(dest)
                if not os.path.exists(dest):
                    os.rename(src, dest)
                last_min_age = min_age

        self.last_rotate = now

    def save(self):
        sections = list(self.keys())
        sections.sort(key=lambda k: (
            self.ALLOWED_SECTIONS.index(k) if k in self.ALLOWED_SECTIONS else 99+len(k)))

        reordered = {}
        for section in sections:
            if len(self[section]) == 0:
                self.remove_section(section)
            else:
                reordered[section] = self._sections[section]
        self._sections = reordered

        self.rotate()
        with open(self.filepath, 'w') as fd:
            fd.write(self.PREAMBLE)
            self.write(fd)
        os.chmod(self.filepath, 0o600)

    def temp_aes_key(config, temp_key):
        old_key = config.aes_key
        class ctx:
            def __enter__(self, *args):
                config.aes_key = temp_key
            def __exit__(self, *args):
                config.aes_key = old_key
        return ctx()

    def key_desc(self, section, option):
        return re.sub(self.DIGIT_RE, 'N', section+'/'+option)

    def provide_passphrase(self, passphrase, contacts=None):
        pass_key = make_aes_key(
            stretch_with_scrypt(bytes(passphrase, 'utf-8'), b'config'))

        is_new = False
        config_key = None
        with self.temp_aes_key(pass_key):
            if 'config_key' not in self[self.SECRETS]:
                config_key = 'CONF_KEY:%s' % generate_recovery_code()
                self.set_private(self.SECRETS, 'config_key', config_key)
                is_new = True
            try:
                config_key = self[self.SECRETS]['config_key']
                if not config_key.startswith('CONF_KEY:'):
                    raise PermissionError('Incorrect Passphrase')
            except UnicodeDecodeError:
                raise PermissionError('Incorrect Passphrase')

        if is_new and contacts and not self.getboolean(
                self.GENERAL, 'recovery_svc_disable', fallback=False):
            url = self.get(self.GENERAL, 'recovery_svc_url',
                fallback=RECOVERY_SERVICE_URL)
            try:
                rs = RecoverySvc(url)
                hint = 'Password recovery for %s v%s' % (APPNAME_UC, APPVER)
                rdata = RecoverableData.ForData(config_key, rs, hint, contacts)
                rdata.save_to_config(self, self.RECOVERY)
            except OSError:
                self.set(self.SECRETS, 'config_key', None)
                raise PermissionError('Recovery unavailable, aborting')

        if config_key is not None:
            if (self.aes_key is not None) and self.aes_key != config_key:
                raise PermissionError('Oh dear, we already have an AES key')
            self.aes_key = make_aes_key(bytes(config_key, 'latin-1'))

    has_crypto_enabled = property(lambda s: ('master_key' in s[s.SECRETS]))

    def generate_master_key(self):
        if self.aes_key is None:
            raise PermissionError('Refusing to set a master key without a passphrase')
        if 'master_key' in self[self.SECRETS]:
            raise PermissionError('Cravenly refusing to overwrite master key')
        self.set_private(self.SECRETS, 'master_key', generate_recovery_code())

    def get_aes_key(self, use_context):
        mk = self.get(self.GENERAL, 'master_key')
        if mk is None:
            raise KeyError('Master key is unset')
        return make_aes_key(bytes(mk, 'latin-1'), bytes(use_context, 'utf-8'))

    def allowed_section(self, section):
        if section in self.ALLOWED_SECTIONS:
            return True
        for prefix in self.ALLOWED_SECTION_PREFIXES:
            if section.startswith(prefix):
                return True
        return False

    def _aes_key_iv(self):
        if self.aes_key is None:
            raise PermissionError('AES key is not set')
        self.iv[-1] += 1
        return (self.aes_key, struct.pack('IIII', *self.iv))

    def __getitem__(self, section):
        if not self.has_section(section):
            if self.allowed_section(section):
                self.add_section(section)
        return super().__getitem__(section)

    def get(self, section, option, *, raw=False, vars=None, fallback=_UNSET):
        if not self.has_section(section):
            if self.allowed_section(section):
                self.add_section(section)
        val = super().get(section, option, raw=raw, vars=vars, fallback=fallback)
        if isinstance(val, str) and val[:2] == '::':
            val = dumb_decode(val[2:], aes_key=self.aes_key)
        return val

    def set(self, section, option, value=None, save=True):
        if self.key_desc(section, option) in self.keep_private:
            return self.set_private(section, option, value=value, save=save)

        if not self.has_section(section):
            if self.allowed_section(section):
                self.add_section(section)
        if value is not None:
            encoded = dumb_encode_asc(value)
            if encoded[:1] != 'U':
                value = '::' + encoded
            super().set(section, option, value=value)
        else:
            del self[section][option]
        if save:
            self.save()

    def _write_section(self, fp, section_name, section_items, delimiter):
        def sort_key(k):
            return (['%8.8d' % int(p) for p in k[0].split('.')
                         if self.DIGIT_RE.match(p)]
                + ['00000000', ('%4.4d' % len(k[0]))] + list(k))
        section_items = sorted(list(section_items), key=sort_key)
        return super()._write_section(fp, section_name, section_items, delimiter)

    def set_private(self, section, option, value=None, save=True):
        if value is not None:
            value = '::' + dumb_encode_asc(value, aes_key_iv=self._aes_key_iv())
        if self.key_desc(section, option) not in self.keep_private:
            self.keep_private.add(self.key_desc(section, option))
        if value is None:
            del self[section][option]
        else:
            super().set(section, option, value=value)
        if save:
            self.save()


if __name__ == '__main__':
    if os.path.exists('/tmp/config.rc'):
        os.remove('/tmp/config.rc')

    ac = AppConfig('/tmp')
    ac.provide_passphrase('Hello world, this is my passphrase')
    ac.provide_passphrase('Hello world, this is my passphrase')
    try:
        ac.provide_passphrase('Bogus')
        assert(not 'reached')
    except PermissionError:
        pass
    try:
        ac.generate_master_key()
    except PermissionError:
        pass

    ac['Profile 1'].update({
        'username': 'Bjarni',
        'context.1.foo': 'bar',
        'context.2.foo': 'bar',
        'context.1.account.1.password': 'hello world',
        'context.1.account.2.password': 'hello world',
        'context.2.account.2.password': 'hello world'})

    ac.set_private(ac.PROFILE_PREFIX + '1', 'password', 'very secret password')
    ac.set(ac.PROFILE_PREFIX + '1', 'password', 'another very secret password')

    ac.recovery_svc.host = 'localhost'
    ac.recovery_svc.port = '80'
    assert(ac[ac.RECOVERY_SVC]['host'] == 'localhost')
    assert(ac.recovery_svc.kite_name is None)
    assert(ac.recovery_svc.port == 80)
    ac.recovery_svc.kite_name = 'fake.example.org'
    assert('kite_name' in ac.recovery_svc)
    assert(ac.recovery_svc.magic_test() == 'magic')
    ac.recovery_svc.kite_name = None
    ac.recovery_svc.host = None
    ac.recovery_svc.port = None
    ac.save()

    assert(len(ac.get_aes_key('silly things')) == 16)
    assert(ac.get_aes_key('storage') != ac.get_aes_key('silly things'))
    assert(ac.get_aes_key('same') == ac.get_aes_key('same'))

    os.remove('/tmp/config.rc')
    print('Tests passed OK')
