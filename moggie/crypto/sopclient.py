# This is a wrapper for invoking any tool which implements the
# Stateless OpenPGP Command-Line Interface, as defined in 
# https://datatracker.ietf.org/doc/html/draft-dkg-openpgp-stateless-cli-01
#
# We build on this in an attempt to minimize the lockin with any
# particular OpenPGP implementation.
#
import datetime
import threading
from ..util.safe_popen import Unsafe_Popen, Safe_Popen, Safe_Pipe, PIPE


def background_run(method, *args):
    th = threading.Thread(target=method, args=args)
    th.daemon = True
    th.start()
    return th


def background_collect(method):
    sink = []
    def _collector():
        sink.append(method())
    th = background_run(_collector)
    return th, sink


def background_send(fd, data):
    data = bytes(data, 'utf-8') if isinstance(data, str) else data
    def _sender():
        fd.write(data)
        fd.close()
    return background_run(_sender)


def sop_date(ts):
    if not ts or (ts == '-'):
        return '-'
    if not isinstance(ts, datetime.datetime):
        ts = datetime.datetime.fromtimestamp(int(ts))
    return '%4.4d-%2.2d-%2.2dT%2.2d:%2.2d:%2.2dZ' % (
        ts.year, ts.month, ts.day, ts.hour, ts.minute, ts.second)


def sop_date_to_datetime(sd):
    if sd in (None, '-'):
        return None
    return datetime.datetime.strptime(sd, '%Y-%m-%dT%H:%M:%S%z')


class SOPError(IOError):
    def __init__(self, code, msg):
        super().__init__(str(msg, 'utf-8') if isinstance(msg, bytes) else msg)
        self.errno = code


class StatelessOpenPGPClient:
    def __init__(self, binary):
        self.binary = binary
        self.profiles = {}

    def make_pipe(self, we_read=False):
        pipe_obj = Safe_Pipe()
        fno = (pipe_obj.write_end if we_read else pipe_obj.read_end).fileno()
        return fno, pipe_obj

    def popen(self, *arguments, binary=None, keep_open=[]):
        command = [binary or self.binary] + list(arguments)
        #print('RUNNING: %s, keep_open=%s' % (command, keep_open))
        return Safe_Popen(command,
            stdin=PIPE, stdout=PIPE, stderr=PIPE,
            keep_open=keep_open)

    def run(self, *arguments, input_data=b'', keep_open=[], timeout=60):
        try:
            if isinstance(input_data, str):
                input_data = bytes(input_data, 'utf-8')
            child = self.popen(*arguments, keep_open=list(keep_open))
            so, se = child.communicate(input=input_data, timeout=timeout)
            #print('RETURNED: %s / %s / %s' % (child.returncode, so, se))
            return child.returncode, so, se
        except KeyboardInterrupt:
            raise
        except Exception as e:
            import traceback
            traceback.print_exc()
            return -1, b'', bytes(traceback.format_exc(), 'utf-8')

    def list_profiles(self, subcommand='generate-key'):
        if self.profiles.get(subcommand) is None:
            rc, so, se = self.run('list-profiles', subcommand)
            if rc != 0:
                raise SOPError(rc, se)
            self.profiles[subcommand] = dict(
                l.split(': ', 1) for l in so.strip().splitlines())
        return self.profiles.get(subcommand, {})

    def generate_key(self, *userids, password=b'', profile=None):
        """
        Return a new (ascii armored) public/private keypair, generated
        using the given user IDs and profile. If a password is provided,
        the secret key material will be encrypted using the password.
        """
        if profile and profile not in self.list_profiles('generate-key'):
            raise SOPError(-1, 'Unknown SOP profile: %s' % profile)

        pipes = {}
        args = []
        if password:
            args.append('--with-key-password=@FD:0' % pipe_n)
        if profile:
            args.append('--profile=%s' % profile)
        if userids:
            args.append('--')
            args.extend(userids)

        rc, so, se = self.run('generate-key', *args, input_data=password)
              #, input_data=password)
        if rc != 0:
            raise SOPError(rc, se)

        return str(so, 'utf-8')

    def extract_cert(self, private_key):
        """
        Return the (ascii armored) sharable public key part from a keypair
        as generated by the `generate_key` method.
        """
        rc, so, se = self.run('extract-cert', input_data=private_key)
        if rc != 0:
            raise SOPError(rc, se)
        return str(so, 'utf-8')

    def sign(self, data, *keys):
        """
        Sign the data using the provided keys. Returns (micalg, signature).
        Input key material and the outputted signature should/will be ascii
        armored.
        """
        alg_fd, alg_pipe = self.make_pipe(we_read=True)
        alg_th, micalg = background_collect(alg_pipe.read)

        keep_open = [alg_fd]
        key_pipes = []
        key_args = []
        for key in keys:
            key_fd, key_pipe = self.make_pipe()
            keep_open.append(key_fd)
            key_pipes.append(key_pipe)  # Avoid garbage collection
            background_send(key_pipe.write_end, key)
            key_args.append('@FD:%d' % key_fd)

        rc, so, se = self.run('sign',
            '--micalg-out=@FD:%d' % alg_fd,
            '--', *key_args,
            input_data=data,
            keep_open=keep_open)

        if rc != 0:
            raise SOPError(rc, se)

        try:
            alg_pipe.write_end.close()
            alg_th.join()
            return str(micalg[0], 'utf-8'), str(so, 'utf-8')
        except IndexError as e:
            se = bytes(str(e), 'utf-8')
        raise SOPError(rc, so+se)

    def parse_verifications(self, verifications):
        def _parse(vinfo):
            ts, signing_key, signing_pkey, details = vinfo.split(None, 3) 
            return {
                'when': sop_date_to_datetime(ts),
                'signing_key': signing_key,
                'primary_key': signing_pkey,
                'details': details}

        return [_parse(l) for l in str(verifications, 'utf-8').splitlines()]

    def verify(self, data, sigs, *certs, not_before=None, not_after=None):
        """
        Returns (bool, details) explaining whether the given signatures
        and certificates match the, data and the signatures fall within the
        window of time defined by the not_before and not_after parameters
        (if specified).
        """
        keep_open = []
        sac_pipes = []
        sac_args = []
        for soc in [sigs] + list(certs):
            soc_fd, soc_pipe = self.make_pipe()
            keep_open.append(soc_fd)
            sac_pipes.append(soc_pipe)  # Avoid garbage collection
            background_send(soc_pipe.write_end, soc)
            sac_args.append('@FD:%d' % soc_fd)

        rc, so, se = self.run('verify',
            '--not-before=%s' % sop_date(not_before),
            '--not-after=%s' % sop_date(not_after),
            '--', *sac_args,
            input_data=data,
            keep_open=keep_open)

        return (0 == rc), self.parse_verifications(so)

    def encrypt(self, data, *certs,
            passwords=[], sign_with=[], sign_passwords=[]):
        args = []
        pipes = []
        keep_open = []

        for arg, values in (
                ('with-password', passwords),
                ('sign-with', sign_with),
                ('sign-password', sign_passwords),
                (None, list(certs))):
            if not arg:
                args.append('--')
            if not isinstance(values, list):
                values = [values]
            for val in values:
                v_fd, v_pipe = self.make_pipe()
                background_send(v_pipe.write_end, val)
                keep_open.append(v_fd)
                pipes.append(v_pipe)
                if arg:
                    args.append('--%s=@FD:%d' % (arg, v_fd))
                else:
                    args.append('@FD:%d' % (v_fd,))

        rc, so, se = self.run('encrypt', '--as=binary', *args,
            input_data=data, keep_open=keep_open)

        if rc:
            raise SOPError(rc, se)

        return str(so, 'utf-8')

    def decrypt(self, ciphertext, *keys,
            passwords=[], key_passwords=[], session_keys=[],
            verify_certs=[], not_before=None, not_after=None):
        args = []
        pipes = []
        keep_open = []

        if verify_certs:
            ver_fd, ver_pipe = self.make_pipe(we_read=True)
            ver_th, verifications = background_collect(ver_pipe.read)
            keep_open.append(ver_fd)
            pipes.append(ver_pipe)
            args.append('--verifications-out=@FD:%d' % ver_fd)
            if not_before:
                args.append('--verify-not-before=%s' % sop_date(not_before))
            if not_after:
                args.append('--verify-not-after=%s' % sop_date(not_after))
        else:
            ver_th = verifications = None

        for arg, values in (
                ('with-password', passwords),
                ('with-session-key', session_keys),
                ('with-key-password', key_passwords),
                ('verify-with', verify_certs),
                (None, list(keys))):
            if not arg:
                args.append('--')
            if not isinstance(values, list):
                values = [values]
            for val in values:
                v_fd, v_pipe = self.make_pipe()
                background_send(v_pipe.write_end, val)
                keep_open.append(v_fd)
                pipes.append(v_pipe)
                if arg:
                    args.append('--%s=@FD:%d' % (arg, v_fd))
                else:
                    args.append('@FD:%d' % (v_fd,))

        rc, so, se = self.run('decrypt', *args,
            input_data=ciphertext, keep_open=keep_open)
        if rc:
            raise SOPError(rc, se)

        if ver_th is not None:
            ver_pipe.write_end.close()
            ver_th.join()
            return so, self.parse_verifications(verifications[0])

        return so


if __name__ == '__main__':
    import os
    moggie_root = os.path.normpath(os.path.join(
        os.path.dirname(__file__), '..', '..'))

    SOPC = StatelessOpenPGPClient

    assert(sop_date(0) == '-')
    assert(sop_date(1) == '1970-01-01T00:00:01Z')

    assert(SOPC('/bin/false').run('hello') == (1, b'', b''))
    assert(SOPC('/bin/true').run('hello') == (0, b'', b''))
    assert(SOPC('/nib/eurt').run('hello')[0] != 0)

    sopgpy = os.path.join(moggie_root, 'tools', 'sopgpy')
    if SOPC(sopgpy).run('version')[0] == 0:
        sop, which = SOPC(sopgpy), 'sopgpy'

    elif SOPC('/usr/bin/sqop').run('version')[0] == 0:
        sop, which = SOPC('/usr/bin/sqop'), 'sqop'

    else:
        sop = which = None

    if sop and which:
        skey = sop.generate_key('Bjarni <bre@example.org>')
        assert(skey.startswith('-----BEGIN PGP PRIVATE'))

        pkey = sop.extract_cert(skey)
        assert(pkey.startswith('-----BEGIN PGP PUBLIC'))

        micalg, signature = sop.sign('hello world', skey)
        assert(micalg[:4] == 'pgp-')
        assert(signature.startswith('-----BEGIN PGP SIG'))

        assert(sop.verify('hello world', signature, pkey)[0])
        assert(not sop.verify('hello planet', signature, pkey)[0])

        encrypted = sop.encrypt('hello world', pkey, sign_with=skey)
        assert(encrypted.startswith('-----BEGIN PGP MESS'))

        cleartext, ver = sop.decrypt(encrypted, skey, verify_certs=pkey)
        assert(b'hello world' == cleartext)
        assert(len(ver) == 1)

        print('Tests passed OK (using %s)' % which)

        #from moggie.crypto.openpgp_keyinfo import get_keyinfo
        #print('%s' % get_keyinfo(pkey))

    else:
        print('Tests passed OK')
