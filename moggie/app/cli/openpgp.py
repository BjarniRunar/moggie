# Low level commands exposing Moggie's OpenPGP support
#
import io
import logging
import os
import sys
import time

from .command import Nonsense, CLICommand, AccessConfig


class WorkerEncryptionWrapper:
    def __init__(self, cli_obj):
        from moggie.jmap.requests import RequestOpenPGP
        self.cli_obj = co = cli_obj
        for op in (
                'get_cert',
                'find_certs',
                'list_certs',
                'get_private_key',
                'find_private_keys',
                'list_private_keys',
                'save_cert',
                'save_private_key',
                'delete_cert',
                'delete_private_key',
                'process_email',
                'list_profiles',
                'generate_key',
                'sign',
                'verify',
                'encrypt',
                'decrypt'):
            def mk_req(_op):
                async def _request(*args, **kwargs):
                    request = RequestOpenPGP(
                        context=co.context,
                        op=_op,
                        args=args,
                        kwargs=kwargs)
                    result = await co.worker.async_jmap(co.access, request)
                    if result.get('error'):
                        logging.error('%s(...): %s' % (_op, result['error']))
                        raise Exception(result['error'])
                    return result['result']
                return _request
            setattr(self, op, mk_req(op))


class CommandOpenPGP(CLICommand):
    """moggie pgp [<command>] [<options> ...]

    Low level commands for interacting with PGP keys, encrypting or
    decrypting.

    ## General options

    These options control the high-level behavior of this command; where
    it loads default settings from, what it does with the message once
    it has been generated, and how the output is formatted:

    %(moggie)s

    ### Examples:

        ...

    ## Known bugs and limitations

    A bunch of the stuff above isn't yet implemented. It's a lot!
    This is a work in progress.

    """
    NAME = 'pgp'
    ROLES = AccessConfig.GRANT_READ
    CONNECT = False    # We manually connect if we need to!
    WEBSOCKET = False
    WEB_EXPOSE = True
    OPTIONS_COMMON = [
        (None, None, 'moggie'),
        ('--context=', ['default'], 'Context to use for default settings'),
        ('--format=',     ['text'], 'X=(text|json|sexp)'),
        ('--stdin=',            [], None), # Allow lots to send stdin (internal)
    ]
    OPTIONS_PGP_SETTINGS = [
        ('--pgp-sop=',          [], '"PGPy" or /path/to/SOP/tool'),
        ('--pgp-key-sources=',  [], 'Ordered list of key stores/sources'),
        ('--pgp-password=',     [], 'Password to use to unlock PGP keys'),
    ]
    OPTIONS_SIGNING = [
        (None, None, 'signing'),
        ('--sign-with=',        [], 'Keys or fingerprints to sign with'),
    ]
    OPTIONS_VERIFYING = [
        (None, None, 'verifying'),
        ('--verify-from=',     [], 'Keys or fingerprints to verify with'),
    ]
    OPTIONS_ENCRYPTING = [
        (None, None, 'encrypting'),
        ('--encrypt-to=',       [], 'Keys or fingerprints to encrypt to'),
    ]
    OPTIONS_DECRYPTING = [
        (None, None, 'decrypting'),
        ('--decrypt-with=',     [], 'Keys or fingerprints to decrypt with'),
    ]
    OPTIONS_AUTOCRYPT = [
        (None, None, 'autocrypt'),
        ('--autocrypt-with=',   [], 'Keys/fingerprints to share/decrypt with'),
        ('--autocrypt=',        [], 'X=(N|auto|/path/to/autocrypt/DB)'),
    ]
    OPTIONS = [OPTIONS_COMMON + OPTIONS_PGP_SETTINGS]

    HTML_SIG_WRAPPER = """\
<html><body><h1>  OpenPGP Digital Signature  </h1><p>

This is a digital signature, which can be used to verify the
authenticity of this message. You can safely discard or ignore
this file if your e-mail software does not support digital
signatures.

</p><pre>\n%s\n</pre><hr>
<i><a href='https://www.mailpile.is/'>Generated by Mailpile</a>.</i>
</body></html>"""

    def __init__(self, *args, **kwargs):
        self.args = []
        self.sign_with = []
        self.verify_from = []
        self.encrypt_to = []
        self.decrypt_with = []
        super().__init__(*args, **kwargs)

    @classmethod
    def configure_passwords(cls, cli_obj, which=['--pgp-password=']):
        for opt in which:
            for i, v in enumerate(cli_obj.options[opt]):
                if v and v.lower() == 'ask':
                    import getpass
                    prompt = 'Password (%s): ' % opt[2:-1]
                    cli_obj.options[opt][i] = getpass.getpass(prompt)

    @classmethod
    def configure_keys(cls, cli_obj):
        for arg in (
                '--sign-with=',
                '--verify-from=',
                '--encrypt-to=',
                '--decrypt-with='):
            keep = []
            for i, v in enumerate(cli_obj.options.get(arg) or []):
                v = v.strip()
                if v.startswith('PGP:'):
                    prefix = v[:4]
                    v = v[4:]
                else:
                    prefix = ''

                if v.startswith('-----BEGIN'):
                    pass
                elif v[:1] in ('.', '/'):
                    try:
                        with open(v, 'r') as fd:
                            key = fd.read().strip()
                            if not key.startswith('-----BEGIN'):
                                raise Nonsense(
                                    'Not an ASCII-armored OpenPGP key: %s' % v)
                            cli_obj.options[arg][i] = prefix + key
                    except (OSError, IOError):
                        raise Nonsense('File not found or unreadable: %s' % v)

    @classmethod
    def get_signing_ids_and_keys(cls, cli_obj):
        ids = {'DKIM': [], 'PGP': []}
        for _id in cli_obj.options['--sign-with=']:
            t, i = _id.split(':', 1)
            ids[t.upper()].append(i)
        return ids

    @classmethod
    def get_encryptor(cls, cli_obj):
        rcpt_ids = {'PGP': []}
        for _id in cli_obj.options['--encrypt-to=']:
            t, i = _id.split(':', 1)
            rcpt_ids[t.upper()].append(i)

        if not rcpt_ids['PGP']:
            return None, '', ''

        pgp_signing_ids = cls.get_signing_ids_and_keys(cli_obj)['PGP']
        sopc, keys = CommandOpenPGP.get_async_sop_and_keystore(cli_obj)

        async def encryptor(data):
            data = bytes(data, 'utf-8') if isinstance(data, str) else data
            encrypt_args = {
                'data': data,
                'recipients': dict(enumerate(rcpt_ids['PGP']))}
            if pgp_signing_ids:
                encrypt_args['signers'] = dict(enumerate(pgp_signing_ids))
                if cli_obj.options['--pgp-password=']:
                    encrypt_args['keypasswords'] = dict(
                        enumerate(cli_obj.options['--pgp-password=']))

            ctxt = await sopc.encrypt(**encrypt_args)
            return ctxt if isinstance(ctxt, str) else str(ctxt, 'utf-8')

        return encryptor, 'OpenPGP', 'asc', 'application/pgp-encrypted'

    @classmethod
    async def get_autocrypt_header(cls, cli_obj, addr, prefer_encrypt=None):
        try:
            ac_key = cli_obj.options['--autocrypt-with='][-1]
        except IndexError:
            return None

        if ac_key.startswith('mutual'):
            ac_key = ac_key[8:]
            if prefer_encrypt is None:
                prefer_encrypt=True

        if not ac_key.startswith('-----PGP'):
            sopc, keys = CommandOpenPGP.get_async_sop_and_keystore(cli_obj)
            for key in await keys.find_certs(ac_key):
                ac_key = key
                break

        import pgpdump
        try:
            key_data = pgpdump.AsciiData(ac_key).data
        except TypeError:
            return None

        import base64
        key_data = str(base64.b64encode(key_data), 'utf-8').strip()
        if len(key_data) > 10000:
            # Key too large, Autocrypt specifies a 10KiB limit!
            return None

        attrs = [('addr', addr), ('keydata', key_data)]
        if prefer_encrypt:
            attrs[1:1] = [('prefer-encrypt', 'mutual')]

        return ('autocrypt', attrs)

    @classmethod
    async def autocrypt(cls, cli_obj, sender, recipients):
        if cli_obj.options['--encrypt-to=']:
            return None

        ac_config = cli_obj.options.get('--autocrypt=') or []
        if (not ac_config or ac_config[-1] == 'N'):
            return None

    @classmethod
    def get_signer(cls, cli_obj, html=False):
        pgp_signing_ids = cls.get_signing_ids_and_keys(cli_obj)['PGP']
        sopc, keys = CommandOpenPGP.get_async_sop_and_keystore(cli_obj)

        async def signer(data):
            data = bytes(data, 'utf-8') if isinstance(data, str) else data
            sign_args = {
                'data': data,
                'wantmicalg': True,
                'signers': dict(enumerate(pgp_signing_ids))}
            if cli_obj.options['--pgp-password=']:
                sign_args['keypasswords'] = dict(
                    enumerate(cli_obj.options['--pgp-password=']))
            sig, micalg = await sopc.sign(**sign_args)
            signature = sig if isinstance(sig, str) else str(sig, 'utf-8')
            if html:
                signature = cls.HTML_SIG_WRAPPER % signature
            return signature, micalg

        ext = 'html' if html else 'asc'
        return signer, 'OpenPGP', ext, 'application/pgp-signature'

    @classmethod
    def get_async_sop_and_keystore(cls, cli_obj, connect=False):
        sop_cfg = (cli_obj.options.get('--pgp-sop=') or [None])[-1]
        keys_cfg = (cli_obj.options.get('--pgp-key-sources=') or [None])[-1]
        if sop_cfg or keys_cfg:
            from moggie.crypto.openpgp.sop import DEFAULT_SOP_CONFIG, GetSOPClient
            from moggie.crypto.openpgp.keystore import PrioritizedKeyStores
            from moggie.crypto.openpgp.keystore.registry import DEFAULT_KEYSTORES
            from moggie.crypto.openpgp.managers import CachingKeyManager
            from moggie.util.asyncio import AsyncProxyObject
            sc = GetSOPClient(sop_cfg or DEFAULT_SOP_CONFIG)
            ks = PrioritizedKeyStores(keys_cfg or DEFAULT_KEYSTORES)
            km = CachingKeyManager(sc, ks)
            return (
                AsyncProxyObject(sc, arg_filter=km.filter_key_args),
                AsyncProxyObject(ks))

        elif cli_obj.worker or connect:
            if not cli_obj.worker:
                 cli_obj.connect()
            we = WorkerEncryptionWrapper(cli_obj)
            return we, we

        else:
            raise Nonsense('Need a backend worker or explicit PGP settings')

    @classmethod
    async def gather_pgp_keys(cls, cli_obj, terms, private_key=None):
        if False:
            yield None

    def configure(self, args):
        #self.preferences = self.cfg.get_preferences(context=self.context)
        args = self.strip_options(args)

        CommandOpenPGP.configure_keys(self)
        CommandOpenPGP.configure_passwords(self)

        self.args = self.configure2(args)
        return self.args

    def configure2(self, args):
        return args

    async def process_key_args(self):
        for arg, priv, target in (
                ('--sign-with=',    True, self.sign_with),
                ('--verify-from=', False, self.verify_from),
                ('--encrypt-to=',  False, self.encrypt_to),
                ('--decrypt-with=', True, self.decrypt_with)):
            for v in self.options.get(arg) or []:
                if v.startswith('PGP:-----BEGIN'):
                    target.append(v[4:])
                elif v.startswith('-----BEGIN'):
                    target.append(v)
                else:
                    async for key in CommandOpenPGP.gather_pgp_keys(
                            self, v, priv):
                        target.append(key)

    def print_results_as_text(self, results):
        results = json.dumps(results, indent=2)
        return self.print(results)

    def print_results(self, results):
        fmt = self.options['--format='][-1]
        if fmt == 'json':
            self.print_json(results)
        if fmt == 'sexp':
            self.print_sexp(results)
        elif fmt == 'text':
            self.print_results_as_text(results)

    async def run(self):
        await self.process_key_args()

        self.print('FIXME %s' % self.decrypt_with)


class CommandPGPGetKeys(CommandOpenPGP):
    """moggie pgp-get-keys [<options>] <search-terms|fingerprint>

    Search for private keys or public certificates.

    %(OPTIONS)s
    """
    NAME = 'pgp-get-keys'
    OPTIONS = [
            CommandOpenPGP.OPTIONS_COMMON +
            CommandOpenPGP.OPTIONS_PGP_SETTINGS
        ]+[[
            ('--keystore=',       [], 'Target a specific keystore'),
            ('--private=',     ['N'], 'X=(Y|N*), search for private keys'),
            ('--timeout=',        [], 'X=<seconds>, set a deadline'),
            ('--max-results=',    [], 'X=<limit>, limit number of results'),
            ('--with-key=',    ['Y'], 'X=(Y*|N), include key material'),
            ('--with-info=',   ['Y'], 'X=(Y*|N), include metadata')]]

    INFO_FMT = '-----BEGIN PGP INFO----\n\n-----END PGP INFO-----\n'

    def print_results_as_text(self, results):
        for fpr, r in results.items():
            info = ''
            if r['info']:
                # FIXME: This is lame
                r['info']['uids'] = ', '.join(
                    uid['email'] for uid in r['info']['uids'])
                info = '\n'.join(
                    '%s: %s' % (k, v) for k, v in r['info'].items()
                    ) + '\n'
            else:
                info = ''
            key = r.get('key', self.INFO_FMT).replace('\r', '')
            pre, post = key.split('\n\n', 1)
            self.print(pre + '\n' + info + '\n' + post)

    async def run(self):
        sop, keys = self.get_async_sop_and_keystore(self, connect=True)

        kwa = {}
        if self.options['--keystore=']:
            kwa['which'] = self.options['--keystore='][-1]
        if self.options['--timeout=']:
            deadline = int(self.options['--timeout='][-1])
            kwa['deadline'] = int(time.time() + 0.5 + deadline)
        if self.options['--max-results=']:
            kwa['max_results'] = int(self.options['--max-results='][-1])

        with_info = self.options['--with-info='][-1] in ('Y', 'y', '1')
        with_keys = self.options['--with-key='][-1] in ('Y', 'y', '1')

        if self.options['--private='][-1] in ('Y', 'y', '1'):
            if with_keys:
                logging.error('FIXME: Require elevated privileges!')
            if self.options['--pgp-password=']:
                kwa['passwords'] = dict(
                    enumerate(self.options['--pgp-password=']))
            list_keys = keys.list_private_keys
            get_key = keys.get_private_key
        else:
            list_keys = keys.list_certs
            get_key = keys.get_cert

        results = {}
        for info in await list_keys(' '.join(self.args), **kwa):
             fpr = info['fingerprint']
             results[fpr] = r = {}
             if with_info:
                 r['info'] = info
             if with_keys:
                 r['key'] = await get_key(fpr, **kwa)

        return self.print_results(results)


class CommandPGPAddCerts(CommandOpenPGP):
    """moggie pgp-add-certs [<options>] <ascii-armored-key>

    %(OPTIONS)s
    """
    NAME = 'pgp-add-certs'

    async def run(self):
        sop, keys = self.get_async_sop_and_keystore(self, connect=True)


class CommandPGPDelCerts(CommandOpenPGP):
    """moggie pgp-del-certs [<options>] <fingerprints>

    %(OPTIONS)s
    """
    NAME = 'pgp-del-certs'

    async def run(self):
        sop, keys = self.get_async_sop_and_keystore(self, connect=True)


class CommandPGPSign(CommandOpenPGP):
    """moggie pgp-sign [<options>]

    %(OPTIONS)s
    """
    NAME = 'pgp-sign'
    OPTIONS = ([
            CommandOpenPGP.OPTIONS_COMMON +
            CommandOpenPGP.OPTIONS_PGP_SETTINGS
        ]+[
            CommandOpenPGP.OPTIONS_SIGNING])

    async def run(self):
        sop, keys = self.get_async_sop_and_keystore(self, connect=True)


class CommandPGPEncrypt(CommandOpenPGP):
    """moggie pgp-encrypt [<options>] ...

    %(OPTIONS)s
    """
    NAME = 'pgp-encrypt'
    OPTIONS = ([
            CommandOpenPGP.OPTIONS_COMMON +
            CommandOpenPGP.OPTIONS_PGP_SETTINGS
        ]+[
            CommandOpenPGP.OPTIONS_SIGNING +
            CommandOpenPGP.OPTIONS_ENCRYPTING])

    async def run(self):
        sop, keys = self.get_async_sop_and_keystore(self, connect=True)


class CommandPGPDecrypt(CommandOpenPGP):
    """moggie pgp-decrypt [<options>]

    %(OPTIONS)s
    """
    NAME = 'pgp-decrypt'
    OPTIONS = ([
            CommandOpenPGP.OPTIONS_COMMON +
            CommandOpenPGP.OPTIONS_PGP_SETTINGS
        ]+[
            CommandOpenPGP.OPTIONS_VERIFYING +
            CommandOpenPGP.OPTIONS_DECRYPTING])

    async def run(self):
        sop, keys = self.get_async_sop_and_keystore(self, connect=True)
